Bugs
====
 o rewrite zombie (bug in movement!, attacks too often, use events, etc...)
 o memleaks, segfaults?


Code
====

 o General:
     o (BIG) move drawing to the objects/menus/etc (create a draw() function)!
     o pointers => references where possible
     o Describe everything using Doxygen styles, move the documentation from
      *.cpp to the headers...
     o Idea: _all_ objects should have a "kore" like the players (curpos thing)
       This would help in many ways and should be a frame information and not an
       image as done for players atm!
     o Use Singletons
     o Introduce abstract classes for all engines and load the corresponding
       concrete class depending on the game_mode instead of using if...

 o Move/Fall/push/crash/collisions:
     o the character should have more information what he hits
     o movements into dense objects should involve a push()
     o I have no idea about how the push should look like, elevators can be pushed
       up, even though you don't collide with them on top
     o characters should be "pushable", eg. a stone that falls down pushes the
       character down or better: an elevator should push the characters up
     o In case of the elevator, the players are somehow "bound" to the elevator (ie.
       it's not like: the elevator moves, the character falls, but they move together)
       Solution: The elevators move function checks all objects it would
         hit, if they are pushable (not dense) they are moved first if
         possible. If it's not possible, do sthg else (stop the elevator and hit the
         object/whatever)...
     o the collision detection and the move/fall code is all a big mess

 o Animations/Events:
     o Allow as complex Images as possible:
       Introduce some image info structure that gives an array of subimages
       Animations can then easily be specified by giving the start and end number in the
       array. A subimage is defined by sthg like SDL_rect relative to the base image
     o As the images of an animation (as in above) may vary in size we should introduce
       sthg like a "base point" type: center/left/right (x) center/top/bottom (y)
       => total: 9 types. Find a default base point...
       which is a point in the animation that stays fixed (related to pos)
     o Using the "base point" type => introduce corresponding drawing methode, which
       consists of a rule on how to map the base point to the position (allignment):
         center/left/right (x) center/top/bottom (y)
         maybe introduce delta values for correction shifts
       => most times the x-alignment probably corresponds to the base point, but the
          y-allignment will almost always be bottom (top: sthg that hangs on a rope)
     o Is the alignment a property of the object (state) or of the animation? => suggest animation
     o Idea: introduce two type of animation for a simple triggered anim:
         still anim: eg. 1 image, trig anim:  animation starting with the still one
       => get rid of once, running
       More generally: do the logic about that outside of the animation structure
     o Maybe introduce an animation base class and do the base_point/allignment logic
       in derived classes somehow? Or use another pattern for this...
     o Allow empty animation, decouple (put more logic in) these relations:
       object (pos, draw?), game(time, state, handler), gfxeng(draw), animation(empty,
       frame, update, time, draw)?, frame, global/current (public, private) properties

     o New anim class/struct:
        /* Global properties */
        SDL_Surface* base_image (or in Frame struct)
        Uint16 start_pos
        Uint16 end_pos / or Uint16 frames
        enum base_point_type
        enum allignment_type
        Uint16 allignment_delta
        Uint16 length
        /* Global Helper values */
        // maybe: bool empty?
        bool still (if frames==1)
        (see above) Uint16 frames / or Uint16 end_pos

        /* (Current) public properties */
	void update(Uint16 dt)
        void draw() <- friend in gfxeng (shift, screen, etc)?
          //information about the current graphic (frame)
          //information about where to draw it (draw_pos)

        /* Current private properties */
        Uint16 cur_im_pos / or Uint16 cur_frame / or Uint16 cur_time
        SDL_Rect* owner_pos (position of the owner) / or const SDL_Rect& owner_pos
        /* Current helper values */
        Frame cur_frame (using private + image info) => w,h (or + Base Image)
        (see above) Uint16 cur_pos / or Uint16 cur_frame / or Uint16 cur_time
        SDL_Rect* (or SDL_Rect& ) draw_pos (using
          (allignment/base_point)_(type/delta) + frame + owner_pos)

     o Make all events quite short, ie. almost all events become animation
       events
     o Maybe: Improve the (very simple) image format:
        - All frame in one sprite sheet for each character (image matrices
          using two description vectors or even more general: offset matrices)
          => see above
        - store rects in an array/vector/whatever or use offset matrices
          => see above
        - do some column/row logics to easy the access
        - eg. set offsets for left, right, mleft, mright...
        - IDEA: just store one side and add some flipping logic to the image
          loading process...
     o IDEA: change Animation* pointers to Animation (or references), leave only
       animation as a pointer and get the address each time...
     o introduce animation events that play an animation and end when it's
       finnished (always ESTATE_BUSY or abort animation?)
     o allow an event length depending on animation length, or: relate events more
       with animations!!!

 o Placement code:
     o IDEA: allow moves from NULL and/or to NULL
     o units should be placed in a way they won't give conflicts, examples:
        - teleport should really teleport (above ground if possible)
        - if a unit's position is too low and it dies the dead corps is
          illegaly placed!
        - the placement should somehow involve checkPlace...

 o Plugins:
     o move object creation code (addObjectByName) to the objects
     o create dynamical plugins for all objects (or compile all in)

 o Ideas/Improvements:
     o IMPROVE?: cleanup set_difference stuff => targets should be updated if
       an object dies in an intelligent way...
     o IDEA: merge otype and ctype and make all moves/etc depend on it
     o IDEA (old): Add attributes:
        - crushable (ie. weapon fart, jump, run destroys them?)
        - bombable (ie. bomb destroys them)
        - multistates? => bridges, door, stone block
     o Give each object a serial number and order the pools with it
       => solves display bug...


Progress
========

 o DONE?: fall logic including gravity!!
 o DONE?: players, object, item, ai, weapons, character
 o PART DONE: effect management (periodic events, permanent effects, etc)
 o DONE: hitlogic


Features/Ideas
==============

 o Make water movements possible (eric)
 o Improve player bar management
 o Add better graphics
 o finnish the map editor
 o OpenGL
 o Simple AI
 o Menu

 o Finnish the vikings:
     - weapons: run, jump2, fart, sword, arm, fire, claws
     - baleog swing (hard one)

 o Add new objects:
     - ladder
     - rope
     - "deadly edges"
     - electric fence

 o Monsters?:
     - stone?
     - plant
     - knight
     - dragon
     - skeleton -> zombie
     - fish
     - firetower
 
 o Weapons?:
    - fireballs
    - sword
    - claw
    - run 
    - fart
    - jump
    - arm

 o Items?:
    - special items

 o IDEA: add horizontal gravity that slows objects down??

